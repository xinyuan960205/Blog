## 一、mysql的基本存储结构

首先Mysql的基本存储结构是**页**(记录都存在页里边)：

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/Innodb%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8.webp)

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/Innodb%E7%9A%84%E5%AD%98%E5%82%A8.webp)

- **各个数据页**可以组成一个**双向链表**

- 而**每个数据页中的记录**又可以组成一个**单向**链表

- - 每个数据页都会为存储在它里边儿的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
  - 以**其他列**(非主键)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

所以说，如果我们写 `select*fromuserwhereusername='Java3y'`这样没有进行任何优化的sql语句，默认会这样做：

- 定位到记录所在的页

- - 需要遍历双向链表，找到所在的页

- 从所在的页内中查找相应的记录

- - 由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会**很慢**！



## 二、索引的优缺点

### 2.1 索引提高检索速度

其实就是**将无序的数据变成有序(相对)**

表的行格式示意图：

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.webp)

我们只在示意图里展示记录的这几个部分：

- `record_type`：记录头信息的一项属性，表示记录的类型，`0`表示普通记录、`2`表示最小记录、`3`表示最大记录、`1`我们还没用过，等会再说～
- `next_type`：记录头信息的一项属性，表示下一条地址的偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。
- `各个列的值`：就是各个数据列的值，其中我们用橘黄色的格子代表`c1`列，深蓝色的格子代表`c2`列，红色格子代表`c3`列。
- `其他信息`：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

为了节省篇幅，我们之后的示意图中会把记录的`其他信息`这个部分省略掉。

要找到id为8的记录简要步骤：

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE.webp)

很明显的是：**没有用索引**我们是需要**遍历双向链表**来定位对应的页，现在通过**“目录”**就可以很快地定位到对应的页上了！

其实底层结构就是**B+树**，B+树作为树的一种实现，能够让我们**很快地**查找出对应的记录。

### 2.2 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 2.3 索引降低增删改的速度

B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合**矮矮胖胖(均衡)的结构**)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。

- B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。
- **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度

## 三、索引使用的数据结构

### 3.1 B+Tree索引

#### 3.1.1 数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/B%2BTree%E5%8E%9F%E7%90%86.png)

#### **3.1.2 操作**

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

#### **3.1.3 与红黑树的比较**

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

### 3.2 哈希索引

哈希索引就是采用一定的**哈希算法**，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可**立刻定位到相应的位置，速度非常快**。

- 本质上就是**把键值换算成新的哈希值**，根据这个**哈希值来定位**。

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.webp)

- 看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：
  - 哈希索引也没办法利用索引完成**排序**
  - 不支持**最左匹配原则**
  - 在有大量重复键值情况下，哈希索引的效率也是极低的---->**哈希碰撞**问题。
  - **不支持范围查询**

#### InnoDB支持哈希索引吗？

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



## 四、聚集和非聚集索引

简单概括：

- 聚集索引就是以**主键**创建的索引
- 非聚集索引就是以**非主键**创建的索引

区别：

- 聚集索引在叶子节点存储的是**表中的数据**
- 非聚集索引在叶子节点存储的是**主键和索引列**
- 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。(拿到主键再查找这个过程叫做**回表**)

**非聚集索引也叫做二级索引**，不用纠结那么多名词，将其等价就行了~

非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

- 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)
- **创建多个单列(非聚集)索引的时候，会生成多个索引树**(所以过多创建索引会占用磁盘空间)

![](https://raw.githubusercontent.com/xinyuan960205/pic_resource/master/image/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.webp)



## 五、覆盖索引

在创建多列索引中也涉及到了一种特殊的索引-->**覆盖索引**

- 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值
- 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢
- 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作！

比如说：

- 现在我创建了索引 `(username,age)`，在查询数据的时候： `selectusername,agefromuserwhereusername='Java3y'andage=20`。
- 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~
- 所以，能使用覆盖索引就尽量使用吧~



## 六、索引最左匹配原则

- 索引可以简单如一个列 `(a)`，也可以复杂如多个列 `(a,b,c,d)`，即**联合索引**。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询 `(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。
- 因此，**列的排列顺序决定了可命中索引的列数**。

例子：

- 如有索引 `(a,b,c,d)`，查询条件 `a=1 and b=2 and c>3 and d=4`，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)

为什么能命中c？

举个简单例子： `select * from user where age>30;` 如果在age列创建索引，那你说会走索引吗？

#### =、in自动优化顺序

**不需要考虑=、in等的顺序**，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。

例子：

- 如有索引 `(a,b,c,d)`，查询条件 `c>3 and b=2 and a=1 and d<4`与 `a=1 and c>3 and b=2 and d<4`等顺序都是可以的，MySQL会自动优化为 `a=1 and b=2 and c>3 and d<4`，依次命中a、b、c。



## 七、索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

## 八、索引优化

### 8.1 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```SQL
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 8.2 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```SQL
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

### 8.3 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```SQL
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 8.4 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

### 8.5 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 面试





## 参考

- <https://zhuanlan.zhihu.com/p/23624390>
- <https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN###rd>

- 