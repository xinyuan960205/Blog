# 继承与多态
## 一、继承
### 1.1 Java类
在Java中，类文件是以.java为后缀的代码文件，在每个类文件中最多只允许出现一个public类，当有public类的时候，类文件的名称必须和public类的名称相同，若不存在public，则类文件的名称可以为任意的名称（当然以数字开头的名称是不允许的）。

初始化 顺序：

当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，如果已经加载，则直接生成对象。<br>
在类的加载过程中，类的static成员变量会被初始化，另外，如果类中有static语句块，则会执行static语句块。static成员变量和static语句块的执行顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，才会加载这个类，并且只会加载一次。

### 1.2 继承概念
- 继承是所有OOP语言不可缺少的部分，在java中使用extends关键字来表示继承关系。
- 当创建一个类时，总是在继承，如果没有明确指出要继承的类，就总是隐式地从根类Object进行继承。
- 如果两个类存在继承关系，则子类会自动继承父类的方法和变量，在子类中可以调用父类的方法和变量。
- 在java中，只允许单继承，也就是说一个类最多只能显示地继承于一个父类。但是一个类却可以被多个类继承，也就是说一个类可以拥有多个子类。

### 1.3 子类继承父类的成员变量
当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：
1. 能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
2. 对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
3. 对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。

### 1.4 子类继承父类的方法
同样地，子类也并不是完全继承父类的所有方法。
1. 能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
2. 对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
3. 对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。

==注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。==

### 1.4 构造器
子类是不能够继承父类的构造器，但是要注意的是，如果父类的构造器都是带有参数的，则必须在子类的构造器中显示地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super关键字调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。

```java
class Shape{
    protected String name;
    
    public Shape(){
        name = "shape";
    }
    
    public Shape(String name){
        this.name = name;
    }
}

class Circle extends Shape{
    private double radius;
    public Circle(){
        radius = 0;
    }
    
    public Circle(double radius){
        this.radius = radius;
    }
    
    public Circle(double radius, Stirng name){
        this.radius = radius;
        this.name = name;
    }
}
```
这样的代码是没有问题的，如果把父类的无参构造器去掉，则代码必然会出错。

### 1.5 super
super主要有两种用法：
1. super.成员变量/super.成员方法;
2. super(parameter1,parameter2....)

第一种用法主要用来在子类中调用父类的同名成员变量或者方法；第二种主要用在子类的构造器中显示地调用父类的构造器，要注意的是，如果是用在子类构造器中，则必须是子类构造器的第一个语句。

**==一定要慎用继承，除非确定关系真的是IS-A
多用组合！！！==**
## 二、多态
所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

==详细见Java基础中的面向对象基础。==

### 多态实现原理

​    java中的方法调用有静态绑定和动态绑定之分，

- **静态绑定**指的是我们在编译期就已经确定了会执行那个方法的字节码，Java中的静态方法、私有方法以及final修饰的方法的调用，都属于静态绑定，对于重载的实例方法的调用，也是采用静态绑定。方法调用动作会被编译成静态调用指令，该指令对应常量池中方法的符号引用。
- **动态绑定**只有在运行时才能知晓。

   下面从虚拟机运行时的角度来简要介绍多态的实现原理，这里以Java虚拟机（[Java Virtual Machine](http://en.wikipedia.org/wiki/Java_Virtual_Machine), JVM）规范的实现为例。

在JVM执行Java字节码时，**类型信息被存放在方法区中**，通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为方法表），**表中的每一项都是指向相应方法的指针。**

方法表的构造如下：

由于Java的单继承机制，一个类只能继承一个父类，而所有的类又都继承自Object类。方法表中**最先存放的是Object类的方法，接下来是该类的父类的方法，最后是该类本身的方法。**这里关键的地方在于，**如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。**

注意这里只有非私有的实例方法才会出现，并且静态方法也不会出现在这里，原因很容易理解：静态方法跟对象无关，可以将方法地址直接引用，而不像实例方法需要间接引用。

更深入地讲，静态方法是由**虚拟机指令invokestatic**调用的，私有方法和构造函数则是由**invokespecial**指令调用，只有被invokevirtual和invokeinterface指令调用的方法才会在方法表中出现。

由于以上方法的排列特性（Object——父类——子类），使得**方法表的偏移量总是固定的**。例如，对于任何类来说，其方法表中equals方法的偏移量总是一个定值，所有继承某父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。

前面说过，方法表中的表项都是指向该类对应方法的指针，这里就开始了多态的实现：

假设Class A是Class B的子类，并且A改写了B的方法method()，那么在B的方法表中，method方法的指针指向的就是B的method方法入口。

而对于A来说，它的方法表中的method方法则会指向其自身的method方法而非其父类的（这在类加载器载入该类时已经保证，同时JVM会保证总是能从对象引用指向正确的类型信息）。

结合**方法指针偏移量是固定的**以及**指针总是指向实际类的方法域**，我们不难发现多态的机制就在这里：

在调用方法时，实际上必须首先完成实例方法的符号引用解析，结果是该符号引用被解析为方法表的偏移量。虚拟机通过对象引用得到方法区中类型信息的入口，查询类的方法表，当将子类对象声明为父类类型时，形式上调用的是父类方法，此时虚拟机会从实际类的方法表（虽然声明的是父类，但是实际上这里的类型信息中存放的是子类的信息）中查找该方法名对应的指针（这里用“查找”实际上是不合适的，前面提到过，方法的偏移量是固定的，所以只需根据偏移量就能获得指针），进而就能指向实际类的方法了。

我们的故事还没有结束，事实上上面的过程仅仅是利用继承实现多态的内部机制，多态的另外一种实现方式：实现接口相比而言就更加复杂，原因在于，**Java的单继承保证了类的线性关系，而接口可以同时实现多个，这样光凭偏移量就很难准确获得方法的指针。**所以在JVM中，多态的实例方法调用实际上有两种指令：

> **invokevirtual指令用于调用声明为类引用的方法；**
>
> **invokeinterface指令用于调用声明为接口的方法。**

当使用invokeinterface指令调用方法时，就不能采用固定偏移量的办法，只能老老实实挨个找了（当然实际实现并不一定如此，JVM规范并没有规定究竟如何实现这种查找，不同的JVM实现可以有不同的优化算法来提高搜索效率）。我们不难看出，**在性能上，调用接口引用的方法通常总是比调用类的引用的方法要慢。**这也告诉我们，在类和接口之间优先选择接口作为设计并不总是正确的。

## 三、重写和重载

### 3.1 定义
**重载**

简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

**重写**

重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

### 3.2 重载 VS 重写
关于重载和重写，你应该知道以下几点：

> 1、重载是一个编译期概念、重写是一个运行期间概念。
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

### 3.3 例子
#### 3.3.1 重写的例子
下面是一个重写的例子，看完代码之后不妨猜测一下输出结果：
```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }
}
class Hound extends Dog{
    public void sniff(){
        System.out.println("sniff ");
    }

    public void bark(){
        System.out.println("bowl");
    }
}

public class OverridingTest{
    public static void main(String [] args){
        Dog dog = new Hound();
        dog.bark();
    }
}
```
输出结果：
```
bowl
```
上面的例子中，dog对象被定义为Dog类型。在编译期，编译器会检查Dog类中是否有可访问的bark()方法，只要其中包含bark（）方法，那么就可以编译通过。在运行期，Hound对象被new出来，并赋值给dog变量，这时，JVM是明确的知道dog变量指向的其实是Hound对象的引用。所以，当dog调用bark()方法的时候，就会调用Hound类中定义的bark（）方法。这就是所谓的动态多态性。

#### 3.3.2 重写的条件
> 参数列表必须完全与被重写方法的相同；
>
> 返回类型必须完全与被重写方法的返回类型相同；
>
> 访问级别的限制性一定不能比被重写方法的强；
>
> 访问级别的限制性可以比被重写方法的弱；
>
> 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
>
> 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
>
> 不能重写被标示为final的方法；
>
> 如果不能继承一个方法，则不能重写这个方法。

#### 3.3.3 重载的例子
```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }

    //overloading method
    public void bark(int num){
        for(int i=0; i<num; i++)
            System.out.println("woof ");
    }
}
```
上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。

#### 3.3.4 重载的条件
> 被重载的方法必须改变参数列表；
>
> 被重载的方法可以改变返回类型；
>
> 被重载的方法可以改变访问修饰符；
>
> 被重载的方法可以声明新的或更广的检查异常；
>
> 方法能够在同一个类中或者在一个子类中被重载。