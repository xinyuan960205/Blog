# 继承与多态
## 一、继承
### 1.1 Java类
在Java中，类文件是以.java为后缀的代码文件，在每个类文件中最多只允许出现一个public类，当有public类的时候，类文件的名称必须和public类的名称相同，若不存在public，则类文件的名称可以为任意的名称（当然以数字开头的名称是不允许的）。

初始化 顺序：

当程序执行时，需要生成某个类的对象，Java执行引擎会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象，如果已经加载，则直接生成对象。<br>
在类的加载过程中，类的static成员变量会被初始化，另外，如果类中有static语句块，则会执行static语句块。static成员变量和static语句块的执行顺序同代码中的顺序一致。记住，在Java中，类是按需加载，只有当需要用到这个类的时候，才会加载这个类，并且只会加载一次。

### 1.2 继承概念
- 继承是所有OOP语言不可缺少的部分，在java中使用extends关键字来表示继承关系。
- 当创建一个类时，总是在继承，如果没有明确指出要继承的类，就总是隐式地从根类Object进行继承。
- 如果两个类存在继承关系，则子类会自动继承父类的方法和变量，在子类中可以调用父类的方法和变量。
- 在java中，只允许单继承，也就是说一个类最多只能显示地继承于一个父类。但是一个类却可以被多个类继承，也就是说一个类可以拥有多个子类。

### 1.3 子类继承父类的成员变量
当子类继承了某个类之后，便可以使用父类中的成员变量，但是并不是完全继承父类的所有成员变量。具体的原则如下：
1. 能够继承父类的public和protected成员变量；不能够继承父类的private成员变量；
2. 对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
3. 对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名成员变量。如果要在子类中访问父类中同名成员变量，需要使用super关键字来进行引用。

### 1.4 子类继承父类的方法
同样地，子类也并不是完全继承父类的所有方法。
1. 能够继承父类的public和protected成员方法；不能够继承父类的private成员方法；
2. 对于父类的包访问权限成员方法，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能够继承；
3. 对于子类可以继承的父类成员方法，如果在子类中出现了同名称的成员方法，则称为覆盖，即子类的成员方法会覆盖掉父类的同名成员方法。如果要在子类中访问父类中同名成员方法，需要使用super关键字来进行引用。

==注意：隐藏和覆盖是不同的。隐藏是针对成员变量和静态方法的，而覆盖是针对普通方法的。==

### 1.4 构造器
子类是不能够继承父类的构造器，但是要注意的是，如果父类的构造器都是带有参数的，则必须在子类的构造器中显示地通过super关键字调用父类的构造器并配以适当的参数列表。如果父类有无参构造器，则在子类的构造器中用super关键字调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。

```java
class Shape{
    protected String name;
    
    public Shape(){
        name = "shape";
    }
    
    public Shape(String name){
        this.name = name;
    }
}

class Circle extends Shape{
    private double radius;
    public Circle(){
        radius = 0;
    }
    
    public Circle(double radius){
        this.radius = radius;
    }
    
    public Circle(double radius, Stirng name){
        this.radius = radius;
        this.name = name;
    }
}
```
这样的代码是没有问题的，如果把父类的无参构造器去掉，则代码必然会出错。

### 1.5 super
super主要有两种用法：
1. super.成员变量/super.成员方法;
2. super(parameter1,parameter2....)

第一种用法主要用来在子类中调用父类的同名成员变量或者方法；第二种主要用在子类的构造器中显示地调用父类的构造器，要注意的是，如果是用在子类构造器中，则必须是子类构造器的第一个语句。

**==一定要慎用继承，除非确定关系真的是IS-A
多用组合！！！==**
## 二、多态
所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

==详细见Java基础中的面向对象基础。==


## 三、重写和重载
### 3.1 定义
**重载**

简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

**重写**

重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

### 3.2 重载 VS 重写
关于重载和重写，你应该知道以下几点：

> 1、重载是一个编译期概念、重写是一个运行期间概念。
> 2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
> 3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法
> 4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）

### 3.3 例子
#### 3.3.1 重写的例子
下面是一个重写的例子，看完代码之后不妨猜测一下输出结果：
```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }
}
class Hound extends Dog{
    public void sniff(){
        System.out.println("sniff ");
    }

    public void bark(){
        System.out.println("bowl");
    }
}

public class OverridingTest{
    public static void main(String [] args){
        Dog dog = new Hound();
        dog.bark();
    }
}
```
输出结果：
```
bowl
```
上面的例子中，dog对象被定义为Dog类型。在编译期，编译器会检查Dog类中是否有可访问的bark()方法，只要其中包含bark（）方法，那么就可以编译通过。在运行期，Hound对象被new出来，并赋值给dog变量，这时，JVM是明确的知道dog变量指向的其实是Hound对象的引用。所以，当dog调用bark()方法的时候，就会调用Hound类中定义的bark（）方法。这就是所谓的动态多态性。

#### 3.3.2 重写的条件
> 参数列表必须完全与被重写方法的相同；
>
> 返回类型必须完全与被重写方法的返回类型相同；
>
> 访问级别的限制性一定不能比被重写方法的强；
>
> 访问级别的限制性可以比被重写方法的弱；
>
> 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
>
> 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
>
> 不能重写被标示为final的方法；
>
> 如果不能继承一个方法，则不能重写这个方法。

#### 3.3.3 重载的例子
```java
class Dog{
    public void bark(){
        System.out.println("woof ");
    }

    //overloading method
    public void bark(int num){
        for(int i=0; i<num; i++)
            System.out.println("woof ");
    }
}
```
上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。

#### 3.3.4 重载的条件
> 被重载的方法必须改变参数列表；
>
> 被重载的方法可以改变返回类型；
>
> 被重载的方法可以改变访问修饰符；
>
> 被重载的方法可以声明新的或更广的检查异常；
>
> 方法能够在同一个类中或者在一个子类中被重载。